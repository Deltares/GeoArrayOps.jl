var documenterSearchIndex = {"docs":
[{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"(Image: CI) (Image: Codecov)","category":"page"},{"location":"#GeoArrayOps","page":"GeoArrayOps","title":"GeoArrayOps","text":"","category":"section"},{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"Geospatial operations, cost and filtering algorithms as used in for elevation rasters.","category":"page"},{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"This is a work in progress","category":"page"},{"location":"#Functionality","page":"GeoArrayOps","title":"Functionality","text":"","category":"section"},{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"Terrain filters, such as Progressive Morphological Filters (PMF, SMF)\nGeospatial cost (friction) operations that mimic PCRaster. These functions should however be more Julian, extensible and scale better.\nVisualization, such as Perceptually Shaded Slope Map (PSSM)","category":"page"},{"location":"#Installation","page":"GeoArrayOps","title":"Installation","text":"","category":"section"},{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"pkg> add https://github.com/Deltares/GeoArrayOps.jl","category":"page"},{"location":"#Reference","page":"GeoArrayOps","title":"Reference","text":"","category":"section"},{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"Modules = [GeoArrayOps]\nOrder   = [:function, :type]","category":"page"},{"location":"#GeoArrayOps.opening-Union{Tuple{T}, Tuple{Matrix{T}, Integer}} where T<:Real","page":"GeoArrayOps","title":"GeoArrayOps.opening","text":"Apply the opening operation to A with window size ω.\n\n\n\n\n\n","category":"method"},{"location":"#GeoArrayOps.pmf-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"GeoArrayOps","title":"GeoArrayOps.pmf","text":"B, flags = pmf(A; ωₘ, slope, dhₘ, dh₀, cellsize)\n\nApplies the progressive morphological filter by Zhang et al. (2003) [zhang2003] to A.\n\nOutput\n\nB::Array{T,2} Maximum allowable values\nflags::Array{Float64,2} A sized array with window sizes if filtered, zero if not filtered.\n\nAfterwards, one can retrieve the resulting mask for A by A .<= B or flags .== 0..\n\nArguments\n\nA::Array{T,2} Input Array\nωₘ::Float64=20. Maximum window size [m]\nslope::Float64=0.01 Terrain slope [m/m]\ndhₘ::Float64=2.5 Maximum elevation threshold [m]\ndh₀::Float64=0.2 Initial elevation threshold [m]\ncellsize::Float64=1. Cellsize in [m]\n\n[zhang2003]: Zhang, Keqi, Shu-Ching Chen, Dean Whitman, Mei-Ling Shyu, Jianhua Yan, and Chengcui Zhang. “A Progressive Morphological Filter for Removing Nonground Measurements from Airborne LIDAR Data.” IEEE Transactions on Geoscience and Remote Sensing 41, no. 4 (2003): 872–82. https://doi.org/10.1109/TGRS.2003.810682.\n\n\n\n\n\n","category":"method"},{"location":"#GeoArrayOps.pssm-Tuple{Matrix{var\"#s5\"} where var\"#s5\"<:Real}","page":"GeoArrayOps","title":"GeoArrayOps.pssm","text":"image = pssm(A; exaggeration, resolution)\n\nPerceptually Shaded Slope Map by Pingel, Clarke. 2014 [pingel2014].\n\nOutput\n\nimage::Gray{T,2} Grayscale image\n\nArguments\n\nA::Array{Real,2} Input Array\nexaggeration::Real=2.3 Factor to exaggerate elevation\nresolution::Real=1.0 Resolution of cell size\n\n[pingel2014]: Pingel, Thomas, and Clarke, Keith. 2014. ‘Perceptually Shaded Slope Maps for the Visualization of Digital Surface Models’. Cartographica: The International Journal for Geographic Information and Geovisualization 49 (4): 225–40. https://doi.org/10/ggnthv.\n\n\n\n\n\n","category":"method"},{"location":"#GeoArrayOps.smf-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"GeoArrayOps","title":"GeoArrayOps.smf","text":"B = smf(A; ω, slope, dhₘ, dh₀, cellsize)\n\nApplies the simple morphological filter by Pingel et al. (2013) [pingel2013] to A.\n\nOutput\n\nB::Array{Float64,2} A filtered version of A\n\nArguments\n\nA::Array{T,2} Input Array\nω::Float64=18. Maximum window size [m]\nslope::Float64=0.01 Terrain slope [m/m]\ncellsize::Float64=1. Cellsize in [m]\n\n[pingel2013]: Pingel, Thomas J., Keith C. Clarke, and William A. McBride. 2013. ‘An Improved Simple Morphological Filter for the Terrain Classification of Airborne LIDAR Data’. ISPRS Journal of Photogrammetry and Remote Sensing 77 (March): 21–30. https://doi.org/10.1016/j.isprsjprs.2012.12.002.\n\n\n\n\n\n","category":"method"},{"location":"#GeoArrayOps.spread-Tuple{Matrix{var\"#s17\"} where var\"#s17\"<:Real, Matrix{var\"#s16\"} where var\"#s16\"<:Real, Real}","page":"GeoArrayOps","title":"GeoArrayOps.spread","text":"spread(points::Matrix{<:Real}, initial::Matrix{<:Real}, friction::Real; distance=Euclidean(), res=1.0)\n\nOptimized (and more accurate) function based on the same friction everywhere.\n\nWhen the friction is the same everywhere, there's no need for searching the shortest cost path, as one can just take a direct line to the input points.\n\nThe calculated cost is more accurate, as there's no 'zigzag' from cell center to cell center.\n\n\n\n\n\n","category":"method"},{"location":"#GeoArrayOps.spread-Tuple{Matrix{var\"#s18\"} where var\"#s18\"<:Real, Matrix{var\"#s19\"} where var\"#s19\"<:Real, Matrix{var\"#s20\"} where var\"#s20\"<:Real}","page":"GeoArrayOps","title":"GeoArrayOps.spread","text":"spread(points::Matrix{<:Real}, initial::Matrix{<:Real}, friction::Matrix{<:Real}; res=1, limit=Inf)\n\nTotal friction distance spread from points as by Tomlin (1983) [tomlin1983]. This is also the method implemented by PCRaster.\n\nOutput\n\nArray{Float64,2} Total friction distance\n\nArguments\n\npoints::Matrix{<:Real} Input Array\ninitial::Matrix{<:Real} Factor to exaggerate elevation\nfriction::Matrix{<:Real} Resolution of cell size\nres=1 Resolution or cell size\nlimit=Inf Initial fill value\n\n[tomlin1983]: Tomlin, Charles Dana. 1983. Digital Cartographic Modeling Techniques in Environmental Planning. Yale University.\n\n\n\n\n\n","category":"method"},{"location":"#GeoArrayOps.spread-Tuple{Matrix{var\"#s22\"} where var\"#s22\"<:Real, Real, Real}","page":"GeoArrayOps","title":"GeoArrayOps.spread","text":"spread(points::Matrix{<:Real}, initial::Real, friction::Real; distance=Euclidean(), res=1.0)\n\n\n\n\n\n","category":"method"},{"location":"#GeoArrayOps.spread2-Tuple{Matrix{var\"#s8\"} where var\"#s8\"<:Real, Matrix{var\"#s7\"} where var\"#s7\"<:Real, Matrix{var\"#s5\"} where var\"#s5\"<:Real}","page":"GeoArrayOps","title":"GeoArrayOps.spread2","text":"spread2(points::Matrix{<:Real}, initial::Matrix{<:Real}, friction::Matrix{<:Real}; res=1, limit=Inf, iterations=3)\n\nPushbroom method for friction costs as discussed by *Eastman (1989) [eastman1989]. This method should scale much better (linearly) than the [tomlin1983] method, but can require more iterations than set by default (3) in the case of maze-like, uncrossable obstacles.\n\nOutput\n\nArray{Float64,2} Total friction distance\n\nArguments\n\npoints::Matrix{<:Real} Input Array\ninitial::Matrix{<:Real} Factor to exaggerate elevation\nfriction::Matrix{<:Real} Resolution of cell size\nres=1 Resolution or cell size\nlimit=Inf Initial fill value\niterations=3 Number of pushbroom iterations\n\n[eastman1989]: Eastman, J. Ronald. 1989. ‘Pushbroom Algorithms for Calculating Distances in Raster Grids’. In Proceedings, Autocarto, 9:288–97.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"GeoArrayOps","title":"Index","text":"","category":"section"},{"location":"","page":"GeoArrayOps","title":"GeoArrayOps","text":"","category":"page"}]
}
